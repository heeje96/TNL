# 데이터베이스_2

사람: kim heeje
태그: 데이터베이스

# 인덱스

| 용어 | 뜻 | 비슷한 단어 |
| --- | --- | --- |
| 클러스터형 인덱스 | 사전처럼 순서대로 정렬된 인덱스 |  |
| 비클러스터형 인덱스 | 북마크를 달아놓은 책과 닮았다. |  |
| Collection 객체 | 여러 원소들을 담을 수 있는 자료구조 |  |
| 참조 | Reference.
다른 변수를 가리키는 변수 | 포인터 |
| 카디널리티 | 특정 컬럼의 중복 수치 |  |

## 인덱스?

- 데이터를 빠르게 찾을 수 있는 장치
- 인덱스는 보통 **B-트리**라는 자료구조로 이루어져 있다.
- 인덱스가 효율적인 이유!
    - 균형잡힌 트리구조
    - 트리 깊이의 **대수 확장성(트리 깊이가 리브 노드 수에 비해 매우 느리게 성장한다.)**
    - 쉽게말해 **엄청 많은 데이터도 트리구조로 짧은 깊이로 저장가능**하다.

## 인덱스, 왜 필요할까?

**쉽게**

인덱스를 사용하지 않으면, 모든 테이블을 뒤져서 값을 찾아야하는 상황이 발생하므로,

책갈피나 목차처럼 색인을 추가해놓으면 빠른 검색이 가능하다.

**어렵게**

만약 index를 사용하지 않은 컬럼을 조회해야하는 상황이면, 전체를 탐색하는 full Scan을 수행해햐한다.

## 인덱스 만들기

요약하자면 대부분 기본키와 세컨더리인덱스로 만든다.

MySQL: 클러스터형 인덱스, 세컨더리 인덱스(보조)

primary Key나 unique not null로 클러스터형 인덱스를 만든다.

MongoDB: 자동 ObjectID (기본키), 복합 인덱스도 설정가능

## 인덱스 최적화

1. 인덱스는 비용이다.
    1. 컬렉션이 수정되었을 때 인덱스도 수정되어야 한다.
    2. 인덱스리스트→컬렉션 순으로 탐색하여 읽는 비용이 든다.
    3. 내용이 수정되면 자료구조 조정에도 비용이 든다.
    
    **결론:**
    
    1. **필드에 인덱스를 많이 설정하는 것은 답이아니다.** 
    2. **또한 컬렉션에서 가져와야 하는 양이 많을 수록 인덱스는 비효율적이다.**
2. 항상 테스팅하라
    1. 서비스에 따라 테스팅을 하면 걸리는 시간을 최소로 만들자.
3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다.
    
    **간단히 말해서, 쉽게 찾을 수 있게 인덱스를 설정한다.**
    
    - 절대적인 우선순위는 없으며 시스템 상황에맞게 적용하는것이 중요

## 인덱스의 장단점?

- 장점:
    - 인덱스가 조회속도개선에 도움이 된다.
    - 전반적인 시스템의 부하를 줄일 수 있다.
- 단점:
    - 입력/수정/삭제에서는 성능이 감수한다.
    - 인덱스를 관리하기 위해 추가 작업, 저장공간이 필요하다.
    - 잘못 쓰면 역효과가 난다.
    - 10%정도의 이상의 데이터를 한번에 찾을 때는 역효과가 날 수 있고, 훨씬 더 느려질 수도 있다.
- 그러면 어떤 곳에 좋은가?
    - 규모가 작지않은 테이블에서 작은 양을 찾을 때
    - CUD가 자주 발생하지 않는 컬럼
    - JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
    - 중복도가 낮은 컬럼

## 조인?

하나의 테이블이 아닌 **두 개 이상의 테이블을 묶어서 하나의 결과물**을 만드는 것.

언어별 쿼리문 : JOIN, lookup

- 내부조인: 교집합
- 왼쪽 조인: 왼쪽의 테이블과, 교집합
- 우측 조인: 오른쪽의 테이블과, 교집합
- 합집합 조인: 왼쪽의 테이블과 교집합이 되는 오른쪽의 집합

## 조인의 원리?

### 중첩루프조인

중첩for로 전~부 탐색하는 것이다 보니 많은 시간이 걸림

### 정렬병합조인

조인할 필드 기준으로 정렬후, 조인작업을 한다.

### 해시조인

해시테이블을 기반으로 조인한다. 

- key value를 이용하여 매우 빠른 검색을 지원한다.
- 특징으로는 등호연산에 특화되어있어서, 부등호연산(>,<)이 자주 사용되는 데이터베이스 검색에는 적합하지 않다.

# 문제

- 인덱스는 왜 효율적일까?
    - 루트, 브랜치 리브노드를 효율적인 단계로 나눠 거쳤고, 모든 요소에 접근할 수 있는 균형잡힌 트리구조와 트리깊이의 대수확장성
- 조인을 왜 할까?
    - 정보를 한 테이블에 몰아넣어버리면 필연적으로 데이터중복이 발생하므로, 데이터의 일관성 유지를 위해 정규화과정을 거치는데, 정규화된 테이블에서 필요한 정보를 얻기 위해서 조인이 필요하다.
- 잘 만든 인덱스
    - CUD가 자주 발생하지 않는 컬럼과
    - JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼을 지정하여
    - 테스트했을때 빠른 인덱스