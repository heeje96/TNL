# 정렬

## 🧵 정렬

- 2개이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순 :ascending)혹은 그 반대의 순서대로(내림차순 :descending) 재배열 하는 것

- **대표적인 정렬 방식**
  - **버블**, **카운팅**, **✨선택**, **✨퀵**, 삽입, 병합

| 알고리즘    | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 | 비고                                   |
| ----------- | ------------- | ------------- | ------------- | -------------------------------------- |
| 버블 정렬   | O(n2)         | O(n2)         | 비교와 교환   | 코딩이 가장 손쉽다.                    |
| 카운팅 정렬 | O(n+k)        | O(n+k)        | 비교환 방식   | n이 비교적 작을 때만 가능하다.         |
| 선택 정렬   | O(n2)         | O(n2)         | 비교와 교환   | 교환의 횟수가 버블, 삽입정렬보다 작다. |
| 퀵 정렬     |               |               |               |                                        |





### 🥉 버블정렬 

- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

- 정렬 과정

  - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막자리까지 이동

- **시간복잡도 O(n2)**

  ```python
  def BubbleSort(a,N):
      for i in range(N - 1, 0, 1):
    		for j in range(0, i):
              if a[j] > a[j + 1]:
                  a[j], a[j + 1] = a[j + 1], a[j]
  ```

###  🥉 카운팅 정렬

- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

- **시간복잡도 O(N + K)** : n은 리스트 길이, k는 정수의 최대값

  - k의 길이만큼 배열이 길어진다.

    ```python
    data   = [0, 4, 1, 3, 1, 2, 4, 1]
    count  = [1, 3, 1, 1, 2] #count[i] = i의 발생 회수
    counts = [1, 4, 5, 6, 7] #누적합
    ...
    counts = [1, 4, 3, 5, 6, 7] #1을 4에 안착시켜놓고, 1을 뺀다.
    temp   = [ ,  ,  , 1,  ,  ,  ,  ]
    
    counts = [1, 3, 5, 6, 7] #4를 7에 안착시켜놓고, 1을 뺀다.
    temp   = [ ,  ,  , 1,  ,  ,  , 4]
    ...
    counts = [0, 1, 4, 5, 6]
    temp   = [0, 4, 1, 3, 1, 2, 4, 1] #완료
    ```

- 코드

  ```python
  def Counting_Sort(A, B, k)
  # A [] -- 입력 배열 (1 to K)
  # B [] -- 정렬된 배열.
  # C [] -- 카운트 배열.
  	C = [0] * (k+1)
      
      for i in range(0, len(A)) :
          C[A[i]] += 1
      for i in range(1, len(C)) :
          C[i] += C[i - 1]
      for i in range(len(B) -1, -1, -1):
          C[A[i]] -= 1
          B[C[A[i]]] = A[i]
  ```



### 🥉선택정렬

- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식

- 정렬과정

  1. 주어진 리스트 중에서 최소 값을 찾는다
  2. 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.
  3. 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.

- **시간 복잡도 O(n2)**

- 코드

  ```python
  arr = [7, 2, 5, 3, 4, 6]
  N = len(arr)
  
  for i in range(N-1):
      minIdex = i #구간의 맨 앞을 최소값으로 가정
      for j in range(i+1,N): #실제 최소값 인덱스 찾기
          if arr[minIdx] > arr[j]: #찾기
              minIdx = j
          arr[minIdx], arr[i] = arr[i], arr[minIdx] #최소값을 구간 맨 앞으로
  ```

  

## 셀렉션 알고리즘(Selection Algorithm)

- 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법을 셀렉션 알고리즘이라 한다.
- 최소값, 최대값  혹은 중간 값을 찾는 알고리즘을 의미하기도 한다.
- 선택 과정
  - 셀렉션은 아래와 같은 과정을 통해 이루어진다.
    - 정렬 알고리즘을 이용하여 자료 정렬하기
    - 원하는 순서에 있는 원소 가져오기

- 아래는 k번째로 작은 원소를 찾는 알고리즘
  - 